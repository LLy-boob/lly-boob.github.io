<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
  <meta name="theme-color" content="#2c3f51">

  <!-- PRIMARY SEO -->
  <title>Block Blaster Official | Free 3D Swipe & Burst Arcade Game (No Download)</title>
  <meta name="description" content="Play Block Blaster ‚Äî the official free 3D swipe-and-burst arcade game. Swipe blocks, blast combos, and survive as speed increases. One wrong move = instant game over. Fast, intense, and WebGL powered. No download required.">

  <!-- Canonical URL -->
  <link rel="canonical" href="https://lly-boob.github.io/">

  <!-- Icons -->
  <link rel="icon" href="https://lly-boob.github.io/favicon.png?v=2" sizes="32x32">
  <link rel="icon" href="https://lly-boob.github.io/favicon.png?v=2" sizes="192x192">
  <link rel="apple-touch-icon" href="https://lly-boob.github.io/favicon.png?v=2">

  <!-- Manifest -->
  <link rel="manifest" href="manifest.json">

  <!-- Google Search Console -->
  <meta name="google-site-verification" content="gZ3LD9X67kObs3lh5Ix7KD9vnSki8VLa6ZONdvCPIxE">

  <!-- Monetag -->
  <meta name="monetag" content="ef7c500bcbab5c68feaab4175d9cfc13">

  <!-- OPEN GRAPH (Facebook, Discord, WhatsApp) -->
  <meta property="og:type" content="website">
  <meta property="og:title" content="Block Blaster ‚Äî Free 3D Swipe & Burst Arcade Game">
  <meta property="og:description" content="Fast-paced 3D WebGL block blasting game. Swipe to burst blocks, survive the speed, and avoid instant game over. Play free ‚Äî no download needed.">
  <meta property="og:url" content="https://lly-boob.github.io/">
  <meta property="og:image" content="https://lly-boob.github.io/favicon.png">
  <meta property="og:image:alt" content="Block Blaster 3D gameplay screenshot">

  <!-- TWITTER CARD -->
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="Block Blaster ‚Äî Free 3D Swipe & Burst Arcade Game">
  <meta name="twitter:description" content="Swipe, blast, survive. Block Blaster is a fast 3D WebGL arcade challenge where one mistake means instant game over. Play free online.">
  <meta name="twitter:image" content="https://lly-boob.github.io/favicon.png">

  <!-- JSON-LD STRUCTURED DATA (Google Rich Results) -->
  <script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "VideoGame",
    "name": "Block Blaster",
    "url": "https://lly-boob.github.io/",
    "image": "https://lly-boob.github.io/og-image.png",
    "description": "Block Blaster is a fast 3D WebGL arcade game where you swipe and burst falling blocks, survive rising speed, and avoid instant game over.",
    "applicationCategory": "GameApplication",
    "operatingSystem": "Web",
    "genre": "Arcade, Reflex, 3D",
    "publisher": {
      "@type": "Organization",
      "name": "LLydra"
    }
  }
  </script>


	<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-5H8LNM4MP1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-5H8LNM4MP1');
	  </script>
  <!-- CSS -->
  <link rel="stylesheet" href="./style.css?v=4">

	  </head>

<body>
  <!-- üî• Hidden SEO Boost Section (Invisible to players) -->
<div style="position:absolute; left:-9999px; top:-9999px; height:0; width:0; overflow:hidden; opacity:0;">
  <h1>Block Blaster ‚Äî Free 3D Swipe & Burst Arcade Game</h1>
  <h2>Fast Reflex Game ‚Ä¢ Swipe Blocks ‚Ä¢ Burst Combos ‚Ä¢ Survive the Speed</h2>

  <p>
    Block Blaster is a fast-paced 3D WebGL arcade game where players swipe and burst incoming blocks before they stack up.
    The speed increases over time, creating an intense survival challenge. One wrong move leads to instant game over,
    making Block Blaster a reaction-based game built for reflex gamers.
  </p>

  <p>
    The game features smooth controls, 3D block animations, burst effects, combos, increasing difficulty,
    and a clean, mobile-friendly layout. Play instantly on any device ‚Äî no download required.
  </p>

  <p>
    Keywords: 3D arcade game, swipe blocks game, reflex survival game, fast reaction game, WebGL block game,
    free arcade browser game, instant play game, burst block challenge, speed survival game.
  </p>
	</div>

<style>
  /* Critical styles for game canvas and layout */
  body, html {
    margin: 0; padding: 0; overflow: hidden; background: #000;
  }
  #gameCanvas {
    width: 100vw; height: 100vh; display: block;
  }
</style>
<link rel="stylesheet" href="style.css?v=4" media="print" onload="this.media='all'">

	
																			 </div>
  <!-- ================================================== -->
<!--   BLOCK BLASTER ‚Äì FINAL PROFESSIONAL PRELOADER    -->
<!-- ================================================== -->
<div id="blockBlasterLoader" style="
    position:fixed; top:0; left:0; width:100vw; height:100vh;
    background: linear-gradient(
        120deg,
        rgba(0,0,0,0.92) 0%,
        rgba(0,0,0,0.88) 50%,
        rgba(0,0,0,0.94) 100%
    );
    backdrop-filter: blur(2px);
    z-index: 99999;
    display:flex; flex-direction:column;
    justify-content:center; align-items:center;
    overflow:hidden;
    font-family: 'Arial Black', Arial, sans-serif;
">

  <canvas id="loaderCanvas" width="420" height="420" style="
      background: transparent;
      filter: drop-shadow(0 0 35px #60d4fa)
              drop-shadow(0 0 60px #a78bfa)
              drop-shadow(0 0 90px #f472b6);
  "></canvas>

  <h1 style="
    color:#60d4fa; font-size:52px; margin:32px 0 10px; letter-spacing:10px;
    text-shadow:
      0 0 18px #60d4fa,
      0 0 35px #60d4fa,
      0 0 55px #a78bfa,
      0 0 85px #f472b6;
    animation: neonPulse 2.2s infinite alternate;
  ">
    BLOCK BLASTER
  </h1>

  <p style="color:#a78bfa; font-size:20px; margin:0; opacity:0.9; letter-spacing:4px;">
    Addictive Block Action
  </p>

  <div style="
      color:#d1d5db; margin-top:30px;
      font-size:16px; letter-spacing:2px;
      text-shadow:0 0 10px #60d4fa;
  ">
    Loading <span class="dots"></span>
  </div>
</div>

<style>
@keyframes neonPulse {
  0% { text-shadow:0 0 10px #60d4fa, 0 0 20px #60d4fa, 0 0 35px #a78bfa; }
  100% { text-shadow:0 0 20px #60d4fa, 0 0 40px #a78bfa, 0 0 70px #f472b6; }
}

.dots::after {
  content: '';
  animation: dots 1.4s infinite steps(1);
}

@keyframes dots {
  0% { content: ''; }
  25% { content: '.'; }
  50% { content: '..'; }
  75% { content: '...'; }
  100% { content: ''; }
}

/* -------------- FIX #1 ------------------ */
/* Loader cannot block or blur buttons */
#blockBlasterLoader {
  pointer-events: none !important;
  z-index: 9999 !important;
}
		</style>

<script>
// Ultra-smooth falling + rotating neon blocks
const loader = document.getElementById('blockBlasterLoader');
const canvas = document.getElementById('loaderCanvas');
const ctx = canvas.getContext('2d');
let blocks = [];

class Block {
  constructor() {
    this.size = Math.random() * 25 + 18;
    this.x = Math.random() * canvas.width;
    this.y = -this.size;
    this.speed = Math.random() * 3.5 + 2.5;
    this.color = ['#ff0080','#00ff9d','#ffea00','#00d0ff','#ff2a6d'][Math.floor(Math.random()*5)];
    this.rotation = 0;
    this.rotSpeed = (Math.random() - 0.5) * 0.25;
  }
  update() {
    this.y += this.speed;
    this.rotation += this.rotSpeed;
    if (this.y > canvas.height + this.size) {
      this.y = -this.size;
      this.x = Math.random() * canvas.width;
    }
  }
  draw() {
    ctx.save();
    ctx.translate(this.x + this.size/2, this.y + this.size/2);
    ctx.rotate(this.rotation);
    ctx.fillStyle = this.color;
    ctx.shadowBlur = 20;
    ctx.shadowColor = this.color;
    ctx.fillRect(-this.size/2, -this.size/2, this.size, this.size);
    ctx.restore();
  }
}

// Create more blocks for richer effect
for(let i = 0; i < 22; i++) blocks.push(new Block());

function animate() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  blocks.forEach(b => { b.update(); b.draw(); });
  if (loader.offsetParent !== null) requestAnimationFrame(animate);
}
animate();

// Responsive canvas
function resizeCanvas() {
  const size = Math.min(380, window.innerWidth * 0.85);
  canvas.width = size;
  canvas.height = size;
}
resizeCanvas();
window.addEventListener('resize', resizeCanvas);

// === HIDE LOADER WHEN GAME IS READY ===
function hideBlockBlasterLoader() {
  loader.style.transition = 'opacity 0.8s ease-out';
  loader.style.opacity = '0';
  setTimeout(() => { loader.style.display = 'none'; }, 900);
}

// Never stuck longer than 4 seconds
setTimeout(hideBlockBlasterLoader, 95000);

// Call this from your script.js when everything is loaded
window.startBlockBlasterGame = hideBlockBlasterLoader;
		</script>



<script>
  (function() {
    const music = document.getElementById('bg-music');

    // Function to safely play music
    function playMusic() {
      if (!music) return;
      music.play().catch(() => {
        // Autoplay blocked? Wait for user interaction
        document.addEventListener('click', () => music.play(), {once: true});
      });
    }

    // 1Ô∏è‚É£ Try playing when page fully loads
    window.addEventListener('load', () => {
      playMusic();
    });

    // 2Ô∏è‚É£ Optional: also try once the game canvas is ready (if you have a function like initGame)
    if (typeof initGame === 'function') {
      const originalInit = initGame;
      initGame = function(...args) {
        originalInit.apply(this, args);
        playMusic(); // ensure music plays after game is initialized
      }
    }
  })();
	</script>
	


<!-- Game canvas -->
<canvas id="c"></canvas>

<!-- Gameplay HUD -->
<div class="hud">
	<div class="hud__score">
		<div class="score-lbl"></div>
		<div class="cube-count-lbl"></div>
	</div>
	<div class="pause-btn"><div></div></div>
	<div class="slowmo">
		<div class="slowmo__bar"></div>
	</div>
</div>

<!-- Menu System -->
<div class="menus">
	<div class="menu menu--main">
		<h1>Block Blaster</h1>
		<button type="button" class="play-normal-btn">PLAY GAME</button>
		<button type="button" class="play-casual-btn">CASUAL MODE</button>
		<div class="credits">3D game by <a href="https://lly-boob.github.io/Ultimate-pong/">Game lovers</a></div>
	</div>
	<div class="menu menu--pause">
		<h1>Paused</h1>
		<button type="button" class="resume-btn">RESUME GAME</button>
		<button type="button" class="menu-btn--pause">MAIN MENU</button>
	</div>
	<div class="menu menu--score">
		<h1>Game Over</h1>
		<h2>Your Score:</h2>
		<div class="final-score-lbl"></div>
		<div class="high-score-lbl"></div>
		<button type="button" class="play-again-btn">PLAY AGAIN</button>
		<button type="button" class="menu-btn--score">MAIN MENU</button>
	</div>
</div>

<!-- MUTE BUTTON -->
<div id="muteBtn" style="position:fixed;bottom:20px;right:20px;width:50px;height:50px;cursor:pointer;z-index:9999;">
  <svg viewBox="0 0 24 24" width="50" height="50" fill="#fff">
    <path d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z"/>
  </svg>
</div>



<!-- MUSIC + MUTE + SAFE PROP ADS INIT + SERVICE WORKER -->
<script>
  const music = document.getElementById('bgMusic');
  const muteBtn = document.getElementById('muteBtn');
  let muted = false;
  let started = false;
  let adLoaded = false;

  // PLAY MUSIC & LOAD PROP ADS ON FIRST TAP
  function startGame() {
    if (started) return;
    started = true;

    // Start music ‚Äî WITH ERROR LOGGING
    music.volume = 0.3;
    music.play()
      .then(() => {
        console.log('Music started');
      })
      .catch((err) => {
        console.warn('Music blocked until interaction:', err.message);
        // Optional: Show hint
        showUnmuteHint();
      });

    

    // Remove listeners
    document.removeEventListener('touchstart', startGame);
    document.removeEventListener('click', startGame);
  }

  // Add listeners
  document.addEventListener('touchstart', startGame, { once: true });
  document.addEventListener('click', startGame, { once: true });

  // MUTE BUTTON
  muteBtn.onclick = () => {
    muted = !muted;
    music.muted = muted;
    muteBtn.innerHTML = muted
      ? `<svg viewBox="0 0 24 24" width="50" height="50" fill="#aaa">
           <path d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02z"/>
         </svg>`
      : `<svg viewBox="0 0 24 24" width="50" height="50" fill="#fff">
           <path d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z"/>
         </svg>`;
  };
</script>

<!-- ===== Simple Fixed Share Button ===== -->
<style>
#shareBtn {
  position: fixed;
  bottom: 14px;
  left: 20px;
  width: 42px;
  height: 42px;
  cursor: pointer;
  z-index: 9999999 !important;
  background: rgba(255,255,255,0.25);
  backdrop-filter: blur(6px);
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  border: 1px solid rgba(255,255,255,0.4);
}

#shareBtn svg {
  width: 55%;
  height: 55%;
  fill: #fff;
}
</style>

<div id="shareBtn">
  <svg viewBox="0 0 24 24">
    <path d="M18 16.08c-.76 0-1.44.3-1.96.77L8.91 12.7c.05-.23.09-.46.09-.7s-.04-.47-.09-.7l7.02-4.11A2.99 
    2.99 0 0018 7.91a3 3 0 10-3-3c0 .24.04.47.09.7L8.07 9.72A3.007 3.007 
    0 006 9a3 3 0 103 3c0-.24-.04-.47-.09-.7l7.12 4.17c.5-.44 
    1.15-.71 1.87-.71a3 3 0 100-6z"/>
  </svg>
</div>

<script>
(function(){
  const shareBtn = document.getElementById("shareBtn");
  const shareURL = window.location.href;

  shareBtn.addEventListener("click", async () => {

    // 1Ô∏è‚É£ If Web Share API works (mobile browser)
    if (navigator.share) {
      try {
        await navigator.share({
          title: "Play Block Blaster!",
          text: "Try this game! It's addictive üî•",
          url: shareURL
        });
        return;
      } catch (e) {
        console.log("Share cancelled.", e);
      }
    }

    // 2Ô∏è‚É£ Fallback for itch.io (copy link)
    try {
      await navigator.clipboard.writeText(shareURL);
      alert("Link copied! Share it with your friends üéÆ");
    } catch (e) {
      console.log("Clipboard blocked, using prompt.");

      // 3Ô∏è‚É£ FINAL fallback (always works)
      prompt("Copy this link:", shareURL);
    }

  });
})();
	</script>

<script>
// =====================================================
// TOUCH INPUT SYSTEM (Fixed + Combined)
// =====================================================

document.addEventListener("DOMContentLoaded", () => {
    const canvas = document.querySelector("canvas");
    if (!canvas) return;

    // 1Ô∏è‚É£ Stop browser from blocking swipes ONLY on canvas
    const blockOpts = { passive: false };
    ["touchstart", "touchmove", "touchend"].forEach(ev => {
        canvas.addEventListener(ev, e => {
            e.preventDefault(); // block scroll / zoom only on canvas
        }, blockOpts);
    });

    // 2Ô∏è‚É£ High-speed touch reader (no lag)
    let lastX = 0, lastY = 0;

    canvas.addEventListener("touchmove", e => {
        const t = e.touches[0];
        lastX = t.clientX;
        lastY = t.clientY;
    }, { passive: true });

    // 3Ô∏è‚É£ Ultra-fast touch pipeline
    canvas.style.touchAction = "none";
});
</script>


<script>
// =====================================================
// ULTRA SMOOTH SWIPE ENGINE v3
// =====================================================

// Your block element ‚Äî change this ID to your player/block
const player = document.getElementById("block");

// Target = where the finger is
let targetX = 0;
let targetY = 0;

// Smooth position = where the block actually glides to
let smoothX = 0;
let smoothY = 0;

// Smooth factor: lower = smoother, higher = faster
const EASE = 0.18;

// Animation loop
function smoothLoop() {
    // Interpolation (lerp)
    smoothX += (targetX - smoothX) * EASE;
    smoothY += (targetY - smoothY) * EASE;

    // GPU transform for ultra smooth motion
    player.style.transform = `translate3d(${smoothX}px, ${smoothY}px, 0)`;

    requestAnimationFrame(smoothLoop);
}
smoothLoop();

// Read the high-speed touch data
document.addEventListener("touchmove", e => {
    const t = e.touches[0];
    targetX = t.clientX;
    targetY = t.clientY;
}, { passive: true });
	</script>
	
	<style>
/* ===== Install Popup Animation ===== */
#autoInstallBox {
    opacity: 0;
    transform: translate(-50%, 20px);
    transition: all 0.6s ease;
}

#autoInstallBox.show {
    opacity: 1;
    transform: translate(-50%, 0);
    animation: bounceIn 0.6s ease-out;
}

@keyframes bounceIn {
    0% { transform: translate(-50%, 40px); }
    60% { transform: translate(-50%, -5px); }
    100% { transform: translate(-50%, 0); }
}
</style>

<!-- ===== AUTO INSTALL POPUP ===== -->
<div id="autoInstallBox" style="
    display:none;
    position: fixed;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    background: #111;
    color: #fff;
    padding: 15px 20px;
    border-radius: 12px;
    box-shadow: 0 4px 15px rgba(0,0,0,0.4);
    z-index: 999999;
    text-align: center;
    font-size: 16px;
">
    <div style="margin-bottom: 10px;">
        Install this game for faster play & offline access!
    </div>

    <button id="autoInstallBtn" style="
        background: #1e90ff;
        border: none;
        color: white;
        padding: 10px 18px;
        border-radius: 8px;
        font-size: 15px;
        cursor: pointer;
    ">
        Install Now
    </button>
</div>

<script>
/* ===== Install Prompt Logic ===== */
let deferredPrompt = null;
let popupShown = false;

window.addEventListener("beforeinstallprompt", (e) => {
    e.preventDefault();
    deferredPrompt = e;

    if (!popupShown) {
        setTimeout(showPopup, 2000); // show after 2 seconds
    }
});

function showPopup() {
    if (deferredPrompt) {
        const box = document.getElementById("autoInstallBox");
        box.style.display = "block";

        // Start animation
        setTimeout(() => {
            box.classList.add("show");
        }, 20);

        popupShown = true;

        // Re-show every 10 seconds until installed
        setTimeout(() => {
            if (deferredPrompt) showPopup();
        }, 10000);
    }
}

document.getElementById("autoInstallBtn").addEventListener("click", () => {
    if (!deferredPrompt) return;

    deferredPrompt.prompt();
    deferredPrompt = null;
    hidePopup();
});

// Hide forever once installed
window.addEventListener("appinstalled", () => {
    deferredPrompt = null;
    hidePopup();
});

function hidePopup() {
    const box = document.getElementById("autoInstallBox");
    box.classList.remove("show");

    setTimeout(() => {
        box.style.display = "none";
    }, 600);
}
</script>


<!-- ========================= -->
<!-- Open in Browser Prompt -->
<!-- ========================= -->
<div id="openBrowserBox">
  <button id="openBrowserBtn">üåê Open in Browser to install</button>
</div>

<style>
  #openBrowserBox {
    position: fixed;
    bottom: 20px;
    left: 20px;
    z-index: 9999;
    display: none;
    pointer-events: auto;
  }

  #openBrowserBtn {
    background: #ff9800;
    color: #fff;
    border: none;
    border-radius: 12px;
    padding: 10px 16px;
    font-size: 14px;
    cursor: pointer;
    box-shadow: 0 2px 6px rgba(0,0,0,0.25);
    transition: transform 0.2s ease, opacity 0.3s ease;
    opacity: 0;
  }

  #openBrowserBox.show #openBrowserBtn {
    opacity: 1;
    transform: scale(1.1);
    animation: bounce 1s infinite alternate;
  }

  @keyframes bounce {
    0% { transform: scale(1.1); }
    100% { transform: scale(1.2); }
  }
</style>

<script>
(function() {
  // Prevent showing multiple times per session
  if (sessionStorage.getItem("openBrowserClicked")) return;

  const ua = navigator.userAgent || navigator.vendor || window.opera;

  // Smart detection: common social media in-app browsers
  const socialAppPatterns = [
    /FBAN|FBAV/i,          // Facebook app
    /Instagram/i,           // Instagram
    /Twitter/i,             // Twitter
    /Snapchat/i,            // Snapchat
    /LinkedIn/i,            // LinkedIn
    /Reddit/i,              // Reddit
    /TikTok/i,              // TikTok
    /WhatsApp/i,            // WhatsApp
    /Messenger/i,           // Messenger
    /Pinterest/i            // Pinterest
  ];

  // Also detect known in-app browser patterns (iOS & Android)
  const inAppBrowserPatterns = [
    /CriOS/i,               // Chrome on iOS
    /FxiOS/i,               // Firefox on iOS
    /GSA/i                  // Google Search app
  ];

  // Check if user is in social media or in-app browser
  const isSocialApp = socialAppPatterns.some(rx => rx.test(ua));
  const isInAppBrowser = /FBAN|FBAV|Instagram|Twitter|Snapchat|LinkedIn|Reddit|TikTok|Messenger|WhatsApp|Pinterest/i.test(ua)
                        && !/Chrome|Safari|Firefox|Edge/i.test(ua);

  if (!isSocialApp && !isInAppBrowser) return; // Exit if not social media browser

  const box = document.getElementById("openBrowserBox");
  const btn = document.getElementById("openBrowserBtn");

  // Show button after a short delay
  setTimeout(() => {
    box.style.display = "block";
    requestAnimationFrame(() => box.classList.add("show"));
  }, 2000);

  // Open page in default browser
  btn.addEventListener("click", () => {
    window.open(window.location.href, "_blank");

    // Hide and mark as clicked
    box.classList.remove("show");
    setTimeout(() => box.style.display = "none", 300);
    sessionStorage.setItem("openBrowserClicked", "true");
  });
})();
	</script>


  <!-- All your existing HTML (canvas, hud, menus, mute button, etc.) stays 100% the same -->
  <canvas id="c"></canvas>
  <div class="hud">‚Ä¶</div>
  <div class="menus">‚Ä¶</div>
  <div id="muteBtn">‚Ä¶</div>
  <div id="shareBtn">‚Ä¶</div>
  <!-- etc. keep everything you already have -->



  <!-- ===================================================== -->
  <!--         MAGIC PERFORMANCE AUTO-ADAPTER ENGINE         -->
  <!-- ===================================================== -->
<script src="https://cdn.jsdelivr.net/npm/detect-gpu@5.0.38/dist/detect-gpu.min.js" defer></script>
  <script>
    // This whole block runs once at startup and decides the quality level
    (async () => {
      const gpu = new GpuJsDetector();
      const result = await gpu.getGPUTier({
        mobileBenchmarkPercentile: 50,   // realistic for phones
        desktopBenchmarkPercentile: 50
      });

      // tier goes from 0 (very weak) ‚Üí 3 (high-end)
      const tier = result.tier; // 0, 1, 2 or 3 (or "WEBGL_UNSUPPORTED")
      
      let scale = 1.0;
      let targetFps = 60;
      let lowQualityMode = false;

      if (tier <= 1) {               // very low-end phones (most Android < $200)
        scale = 0.65;
        targetFps = 30;
        lowQualityMode = true;
      } else if (tier === 2) {       // medium phones / old iPads
        scale = 0.85;
        targetFps = 45;
      } else if (tier >= 3) {        // good phones, all PCs
        scale = 1.0;
        targetFps = 60;
      }

      // Expose to your game code (script.js can read these if you ever want)
      window.PERF_TIER = tier;
      window.PERF_SCALE = scale;
      window.PERF_FPS = targetFps;
      window.LOW_QUALITY = lowQualityMode;

      // 1. Force lower resolution (the #1 fix for laggy WebGL on mobile)
      const canvas = document.getElementById('c');
      function resizeCanvas() {
        const dpr = window.devicePixelRatio || 1;
        const actualScale = lowQualityMode ? scale : Math.min(scale, 1);
        
        canvas.width  = canvas.clientWidth  * dpr * actualScale;
        canvas.height = canvas.clientHeight * dpr * actualScale;

        // CSS size stays full screen (sharp on high-dpi, pixelated but fast on low)
        canvas.style.width  = '100%';
        canvas.style.height = '100%';
      }

      resizeCanvas();
      window.addEventListener('resize', resizeCanvas);

      // 2. Cap FPS on low-end devices (prevents burning CPU/GPU)
      let lastFrameTime = 0;
      const originalRaf = window.requestAnimationFrame;
      window.requestAnimationFrame = function(callback) {
        return originalRaf(function(time) {
          if (!lastFrameTime) lastFrameTime = time;
          const delta = time - lastFrameTime;
          const interval = 1000 / targetFps;
          
          if (delta > interval) {
            lastFrameTime = time - (delta % interval);
            callback(time);
          } else {
            originalRaf(arguments.callee);
          }
        });
      };

      // 3. Remove 300 ms tap delay + make touch super responsive
      canvas.style.touchAction = 'none';
      ['touchstart','touchmove','touchend','touchcancel'].forEach(ev => {
        canvas.addEventListener(ev, e => e.preventDefault(), { passive: false });
      });

      // 4. Optional: force lower precision in shaders on trash GPUs
      // (many raw WebGL games use highp everywhere ‚Üí death on Mali/Adreno 5xx)
      if (lowQualityMode) {
        const originalGetContext = HTMLCanvasElement.prototype.getContext;
        HTMLCanvasElement.prototype.getContext = function(type, attributes) {
          if (type.includes('webgl')) {
            attributes = attributes || {};
            attributes.precisionHint = 'low'; // custom flag we add
          }
          return originalGetContext.call(this, type, attributes);
        };
      }

      console.log(`Block Blaster ‚Üí Device tier \( {tier} ‚Üí Scale: \){scale.toFixed(2)}, FPS cap: ${targetFps}`);
    })();
	</script>
	
	<script>
// ===================== Performance Helper for Swipe Match-3 =====================

// FPS monitor (optional, helps see if game drops frames)
(function() {
    let last = performance.now();
    let frames = 0;
    function fpsMonitor() {
        const now = performance.now();
        frames++;
        if (now - last >= 1000) {
            console.log("FPS:", frames);
            frames = 0;
            last = now;
        }
        requestAnimationFrame(fpsMonitor);
    }
    fpsMonitor();
})();

// Hardware acceleration helper for tiles
function accelerateTiles(tileSelector) {
    const tiles = document.querySelectorAll(tileSelector);
    tiles.forEach(tile => {
        tile.style.transform = "translate3d(0,0,0)";
        tile.style.willChange = "transform";
    });
}

// Smooth animation wrapper using requestAnimationFrame
function animateTile(tile, targetX, targetY, duration = 300, callback) {
    const startX = tile.offsetLeft;
    const startY = tile.offsetTop;
    const deltaX = targetX - startX;
    const deltaY = targetY - startY;
    const startTime = performance.now();

    function step(now) {
        const elapsed = now - startTime;
        const progress = Math.min(elapsed / duration, 1);
        tile.style.transform = `translate3d(${deltaX*progress}px, ${deltaY*progress}px, 0)`;
        if (progress < 1) {
            requestAnimationFrame(step);
        } else {
            if (callback) callback();
        }
    }
    requestAnimationFrame(step);
}

// Throttle expensive game updates (e.g., combo checks)
function throttle(fn, limit = 50) {
    let lastCall = 0;
    return function(...args) {
        const now = performance.now();
        if (now - lastCall >= limit) {
            lastCall = now;
            fn.apply(this, args);
        }
    }
}

// ===================== Usage Examples =====================

// 1. Accelerate all tiles
accelerateTiles(".tile"); // replace ".tile" with your tile class

// 2. Animate a tile smoothly
// animateTile(document.querySelector(".tile"), 200, 300, 300);

// 3. Throttle heavy functions
// const checkCombosThrottled = throttle(checkCombos, 50);
	</script>

	<!-- ====================================================== -->
<!-- PERFORMANCE BOOST ENGINE v3 ‚Äî ADAPTIVE SUPER BOOSTER    -->
<!-- Ultra-safe sandbox: no overrides, opt-in adaptions only -->
<!-- Paste BEFORE your game script                          -->
<!-- ====================================================== -->
<script>
(function () {
  // single, immutable global handle for optional diagnostics (safe & minimal)
  if (window.__PerfBoostV3) return; // prevent double-load
  const __PerfBoostV3 = (() => {

    /* ===========================
       Internal state (private)
       =========================== */
    const state = {
      tier: "unknown",
      fps: 60,
      lowDevice: false,
      frameTimes: [],
      lastNow: performance.now(),
      mem: { usedMB: null, totalMB: null },
      thermalThrottled: false,
      lastThermalCheck: 0,
      emergencyMode: false
    };

    /* ===========================
       Utilities (no globals touched)
       =========================== */
    function safeLog(...args) {
      // reduce noise; use console.debug to keep logs hidden by default
      if (window.location.search.indexOf("perfboost_debug") !== -1) {
        console.debug("[PerfBoostV3]", ...args);
      }
    }

    function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }

    /* ===========================
       Passive FPS & Memory Monitor
       - does NOT replace requestAnimationFrame
       - purely observational
       =========================== */
    function monitorLoop() {
      try {
        requestAnimationFrame((now) => {
          const delta = now - state.lastNow || 16.67;
          state.lastNow = now;
          const fps = 1000 / delta;
          state.frameTimes.push(fps);
          if (state.frameTimes.length > 30) state.frameTimes.shift();
          const avg = state.frameTimes.reduce((a,b)=>a+b,0) / state.frameTimes.length || fps;
          state.fps = Math.round(avg);
          // mark low device if sustained low fps
          if (avg < 40) state.lowDevice = true;
          else if (avg > 48) state.lowDevice = false;

          // optional memory read (non-fatal if unavailable)
          if (performance && performance.memory) {
            const mem = performance.memory;
            // usedJSHeapSize / (1024*1024) gives MB
            state.mem.usedMB = Math.round(mem.usedJSHeapSize / 1048576);
            state.mem.totalMB = Math.round(mem.jsHeapSizeLimit / 1048576);
            // if used exceeds 85% -> emergency
            if (state.mem.usedMB && state.mem.totalMB &&
                state.mem.usedMB / state.mem.totalMB > 0.85) {
              state.emergencyMode = true;
            } else {
              state.emergencyMode = false;
            }
          }

          // lightweight thermal-like heuristic (doesn't require special APIs)
          // check every 3s
          const nowTs = Date.now();
          if (nowTs - state.lastThermalCheck > 3000) {
            state.lastThermalCheck = nowTs;
            // crude: if recent fps dropped drastically -> possible throttling
            const recent = state.frameTimes.slice(-5);
            if (recent.length >= 3) {
              const minRecent = Math.min(...recent);
              if (minRecent < Math.max(20, state.fps * 0.5)) {
                state.thermalThrottled = true;
              } else {
                state.thermalThrottled = false;
              }
            }
          }
        });
      } catch (e) {
        // never throw
      } finally {
        // continue monitoring
        setTimeout(monitorLoop, 1); // minimal delay; purely observational
      }
    }

    /* ===========================
       Adaptive helpers (safe, non-invasive)
       - These functions DO NOT override your game loop.
       - They only *offer* guidance or opt-in effects.
       =========================== */

    // 1) Recommended frame-skip decision ‚Äî game can call this each frame.
    //    returns {skipRender: boolean, skipPhysics: boolean}
    function getFrameAllowance() {
      const fps = state.fps || 60;
      // skip more often when fps low or emergency
      const emergency = state.emergencyMode || state.thermalThrottled;
      // compute probability of skipping render this frame (0..1)
      let skipProb = 0;
      if (fps >= 50 && !emergency) skipProb = 0;
      else if (fps >= 40) skipProb = 0.1;
      else if (fps >= 30) skipProb = 0.25;
      else skipProb = 0.5 + (emergency ? 0.25 : 0);

      // deterministic-ish skip using time seed to avoid heavy logic
      const t = Math.floor(performance.now() / 16); // frame-ish tick
      const seed = (t * 9301 + 49297) % 233280;
      const rand = (seed % 1000) / 1000;
      const skipRender = rand < skipProb;
      const skipPhysics = emergency && (rand < (skipProb * 0.6));

      return { skipRender, skipPhysics, fps: state.fps, emergency };
    }

    // 2) Adaptive scale suggestion ‚Äî safe: does NOT change canvas content,
    //    only suggests a CSS scale factor. Game may read and apply if it wants.
    //    If a canvas has opt-in attribute data-perfboost-scale="auto" we will
    //    apply a non-destructive CSS scale to *that* canvas (no size attr changes).
    function computeScaleSuggestion() {
      // target base resolution ~ device pixel ratio
      const dpr = window.devicePixelRatio || 1;
      let base = 1;
      if (state.lowDevice || state.fps < 40) base = 0.75;
      if (state.emergencyMode || state.fps < 30) base = 0.5;
      return clamp(base, 0.5, 1) / dpr;
    }

    // 3) Auto-attach safe CSS scaling to canvas only if canvas opted in
    function attachCanvasScalingIfOptIn() {
      try {
        // find canvases with data-perfboost-scale="auto"
        const canvases = Array.from(document.querySelectorAll('canvas[data-perfboost-scale="auto"]'));
        if (!canvases.length) return;
        const scale = computeScaleSuggestion();
        canvases.forEach(c => {
          // apply CSS transform only (non-destructive)
          c.style.willChange = "transform";
          c.style.transformOrigin = "0 0";
          // preserve integer pixel sizes visually by using transform scale
          c.style.transform = `scale(${scale})`;
          // optionally reduce CSS layout jitter by setting image-rendering
          c.style.imageRendering = "pixelated";
          // expose applied scale as attribute for game to read
          c.setAttribute("data-perfboost-applied-scale", String(scale));
        });
      } catch (e) {
        // fail silently
      }
    }

    /* ===========================
       Emergency memory/free-up strategy (non-invasive)
       - Removes nodes that are clearly marked by developer
       - Does not touch other DOM
       =========================== */
    function emergencyCleanupSweep() {
      try {
        // only run if emergencyMode true
        if (!state.emergencyMode) return;
        // developers can mark expendable nodes: class .perfboost-disposable
        const nodes = document.querySelectorAll(".perfboost-disposable");
        nodes.forEach(n => {
          try { n.remove(); } catch (e) {}
        });
        safeLog("Emergency cleanup sweep executed, removed:", nodes.length);
      } catch (e) {}
    }

    /* ===========================
       Passive UI: small invisible overlay for status (Shadow DOM)
       - Only present if developer explicitly sets data-perfboost-ui="visible"
       - This ensures ZERO visual interference by default.
       =========================== */
    function maybeCreateStatusOverlay() {
      try {
        const visible = document.querySelector('[data-perfboost-ui="visible"]');
        if (!visible) return;
        // create a tiny non-interactive overlay in shadow root
        const host = document.createElement("div");
        host.style.position = "fixed";
        host.style.right = "6px";
        host.style.bottom = "6px";
        host.style.zIndex = "2147483646"; // very top but non-interactive
        host.style.pointerEvents = "none";
        const shadow = host.attachShadow({mode: "closed"});
        const rootDiv = document.createElement("div");
        rootDiv.style.fontSize = "11px";
        rootDiv.style.padding = "6px 8px";
        rootDiv.style.borderRadius = "6px";
        rootDiv.style.background = "rgba(0,0,0,0.35)";
        rootDiv.style.color = "white";
        rootDiv.style.backdropFilter = "blur(2px)";
        rootDiv.style.pointerEvents = "none";
        rootDiv.textContent = `PerfBoost v3 ‚Äî fps: ${state.fps}`;
        shadow.appendChild(rootDiv);
        document.documentElement.appendChild(host);

        // update loop
        setInterval(() => {
          try {
            rootDiv.textContent = `PerfBoost v3 ‚Äî fps: ${state.fps} tier:${state.tier}${state.emergencyMode ? " ‚ö†" : ""}`;
          } catch (e) {}
        }, 600);
      } catch (e) {}
    }

    /* ===========================
       Non-invasive event broadcast API
       - Game can listen: window.addEventListener('perfboost:update', e=>{})
       - This emits regular read-only snapshots but DOES NOT allow mutation.
       =========================== */
    function broadcastState() {
      try {
        const snapshot = {
          fps: state.fps,
          tier: state.tier,
          lowDevice: state.lowDevice,
          mem: state.mem,
          emergencyMode: state.emergencyMode,
          thermalThrottled: state.thermalThrottled,
          timestamp: Date.now()
        };
        const evt = new CustomEvent('perfboost:update', { detail: snapshot });
        // dispatch non-cancelable to avoid interference
        window.dispatchEvent(evt);
      } catch (e) {}
    }

    /* ===========================
       Init: detect device tier + start loops
       =========================== */
    function detectTier() {
      const cores = navigator.hardwareConcurrency || 2;
      const mem = navigator.deviceMemory || 2;
      const smallScreen = (window.screen.width || 0) < 540 || (window.screen.height || 0) < 540;
      if (cores <= 4 || mem <= 2 || smallScreen) {
        state.tier = "low";
        state.lowDevice = true;
      } else if (cores <= 6) {
        state.tier = "mid";
      } else state.tier = "high";
    }

    // periodic tasks
    function periodicTasks() {
      try {
        attachCanvasScalingIfOptIn();   // safe CSS scaling for opt-in canvases
        emergencyCleanupSweep();        // remove .perfboost-disposable nodes if emergency
        broadcastState();               // emit snapshot
      } catch (e) {}
      setTimeout(periodicTasks, 1000); // run every 1s
    }

    // public read-only API (frozen)
    const publicAPI = Object.freeze({
      // read-only snapshot retrieval
      getInfo: () => ({
        fps: state.fps,
        tier: state.tier,
        lowDevice: state.lowDevice,
        mem: Object.assign({}, state.mem),
        emergencyMode: state.emergencyMode,
        thermalThrottled: state.thermalThrottled
      }),
      // recommended frame allowance helper ‚Äî safe for game loops to call every frame
      getFrameAllowance,
      // compute scale suggestion (game may use or ignore)
      computeScaleSuggestion,
      // developer can trigger a manual light cleanup (only removes .perfboost-disposable)
      manualCleanup: () => { emergencyCleanupSweep(); },
      // version
      version: "3.0.0"
    });

    /* ===========================
       Start everything (non-invasive)
       =========================== */
    function start() {
      detectTier();
      monitorLoop();     // passive FPS/memory monitor
      periodicTasks();   // periodic gentle tasks
      maybeCreateStatusOverlay(); // only if developer opted in
      safeLog("PerfBoostV3 started", publicAPI.getInfo());
    }

    // auto-start after DOMInteractive so it doesn't fight initial parsing
    if (document.readyState === "complete" || document.readyState === "interactive") {
      setTimeout(start, 300);
    } else {
      document.addEventListener("DOMContentLoaded", () => setTimeout(start, 300), { once: true });
    }

    // return public API for diagnostics ‚Äî attach minimal immutable handle
    return publicAPI;
  })();

  // attach a minimal, read-only handle for optional use by the developer
  try {
    Object.defineProperty(window, '__PerfBoostV3', {
      value: __PerfBoostV3,
      writable: false,
      configurable: false,
      enumerable: false
    });
  } catch (e) {
    // if defineProperty fails, silently ignore (still safe)
    window.__PerfBoostV3 = __PerfBoostV3;
  }

})();
</script>
<!-- ====================================================== -->
<!--            PERFORMANCE BOOST ENGINE v3 END            -->
<!-- ====================================================== -->

        
	<!-- ================================ -->
<!--   SAFE AD + OPTIMIZER ENGINE     -->
<!-- ================================ -->
<div id="ad-container" style="width:320px; height:50px; margin:auto; text-align:center; visibility:hidden;">
  <!-- Ad will load here -->
</div>

<script>
(function() {
  if (window.adOptimizerLoaded) return;
  window.adOptimizerLoaded = true;

  const adContainer = document.getElementById('ad-container');
  if (!adContainer) return;

  // Flicker/Glitch Absorber Engine
  const optimizer = {
    buffer: document.createDocumentFragment(), // Temporary offscreen buffer
    ready: false,
    showAd: function(iframe) {
      // Append to buffer first
      this.buffer.appendChild(iframe);
      // Minimal delay to ensure game rendering is stable
      setTimeout(() => {
        adContainer.appendChild(this.buffer);
        adContainer.style.visibility = 'visible';
        this.ready = true;
      }, 200); // 200ms delay is enough to absorb frame glitches
    }
  };

  // Create ad iframe
  const iframe = document.createElement('iframe');
  iframe.src = 'https://example.com/your-ad.html'; // Replace with your ad URL
  iframe.width = '320';
  iframe.height = '50';
  iframe.style.border = '0';
  iframe.style.overflow = 'hidden';
  iframe.loading = 'lazy';
  iframe.allow = 'autoplay; fullscreen';

  // Load ad asynchronously after game init
  window.addEventListener('load', () => {
    setTimeout(() => optimizer.showAd(iframe), 1000); // Delay 1s after game load
  });

})();
</script>
<!-- ================================ -->
<!--   SAFE AD + OPTIMIZER ENGINE END -->
<!-- ================================ -->


         
	
            


	<!-- GAME SCRIPT -->
<script type="module" src="./script.js"></script>
<script src="ads.js"></script>
	
</body>
</html>
