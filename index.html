<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
  <meta name="theme-color" content="#2c3f51">

  <!-- Primary SEO -->
  <title>Block Blaster ‚Äî Free Online Block Puzzle Game | Play Instantly</title>
  <meta name="description" content="Play Block Blaster ‚Äî the ultimate free online block puzzle game! Instantly playable on mobile & desktop. No download, addictive fun, UK Drill music, and simple controls.">
  <link rel="canonical" href="https://lly-boob.github.io/">

  <!-- Favicon & App Icons -->
  <link rel="icon" href="https://lly-boob.github.io/favicon.png?v=2" sizes="32x32">
  <link rel="icon" href="https://lly-boob.github.io/favicon.png?v=2" sizes="192x192">
  <link rel="apple-touch-icon" href="https://lly-boob.github.io/favicon.png?v=2">

  <!-- Manifest for PWA -->
  <link rel="manifest" href="manifest.json">

  <!-- Google Site Verification -->
  <meta name="google-site-verification" content="gZ3LD9X67kObs3lh5Ix7KD9vnSki8VLa6ZONdvCPIxE" />

  <!-- Monetization -->
<meta name="monetag" content="ef7c500bcbab5c68feaab4175d9cfc13">

	

  <!-- Open Graph for Social Sharing -->
  <meta property="og:type" content="website">
  <meta property="og:title" content="Block Blaster ‚Äî Free Online Block Game">
  <meta property="og:description" content="Fast, addictive block puzzle game like Candy Crush. Play now on mobile or desktop ‚Äî no download required, UK Drill music included.">
  <meta property="og:url" content="https://lly-boob.github.io/">
  <meta property="og:image" content="https://lly-boob.github.io/og-image.png">
  <meta property="og:image:alt" content="Block Blaster gameplay screenshot with colorful blocks">

  <!-- Twitter Card -->
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="Block Blaster ‚Äî Free Online Block Game">
  <meta name="twitter:description" content="Play Block Blaster ‚Äî addictive block puzzle game online. Instant play on mobile & desktop. UK Drill soundtrack included.">
  <meta name="twitter:image" content="https://lly-boob.github.io/
	  /og-image.png">

  <!-- JSON-LD structured data -->
  <script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@graph": [
      {
        "@type": "WebSite",
        "@id": "https://lly-boob.github.io/#website",
        "url": "https://lly-boob.github.io/",
        "name": "Block Blaster",
        "description": "Play Block Blaster ‚Äî a fast, addictive block puzzle game played in the browser with UK Drill music.",
        "publisher": {
          "@type": "Organization",
          "name": "LLydra"
        }
      },
      {
        "@type": "Game",
        "name": "Block Blaster",
        "url": "https://lly-boob.github.io/",
        "description": "Fast, addictive block puzzle game playable in-browser on mobile and desktop. UK Drill soundtrack included for immersive gameplay.",
        "image": "https://lly-boob.github.io/
	  /og-image.png",
        "applicationCategory": "GameApplication",
        "operatingSystem": "WEB",
        "genre": "Puzzle, Arcade",
        "audience": {
          "@type": "Audience",
          "audienceType": "Everyone"
        }
      }
    ]
  }
  </script>

  <!-- CSS -->
  <link rel="stylesheet" href="./style.css?v=4">
	  </head>
<body>
  <!-- üî• Hidden SEO Boost Section (Invisible to players) -->
  <div style="position:absolute; left:-9999px; top:-9999px; height:0; width:0; overflow:hidden; opacity:0;">
    <h1>Block Blaster ‚Äî Free Online Block Puzzle Game with Candy Crush Style Swiping</h1>
    <h2>Play Fast, Addictive Block Breaking Game on Mobile & Desktop</h2>
    <h3>Instant Play ‚Ä¢ No Download ‚Ä¢ Arcade Puzzle ‚Ä¢ Swipe & Crush Blocks</h3>
    <p>
      Block Blaster is a free online block puzzle game where you swipe, drop, crush,
      and blast blocks just like the best Candy Crush‚Äìstyle arcade games. 
      Play instantly on mobile or desktop with smooth controls, colorful blocks,
      fast gameplay, and built‚Äëin UK Drill music for a hype experience.
    </p>
    <p>
      The game loads fast, runs directly in the browser, and includes 
      addictive puzzle action, high scores, block combos, multipliers,
      and arcade‚Äëstyle sound effects. Perfect for puzzle lovers, arcade fans,
      and players who enjoy fast, satisfying mechanics.
    </p>
    <p>
      Keywords: block puzzle game, swipe block game, free puzzle online,
      candy crush style puzzle, match blocks, block crush game, fast puzzle game,
      mobile puzzle game, no download puzzle, arcade block breaker,
      UK drill game music, browser games, instant play games.
    </p>
																			 </div>
  
<!-- ================================================== -->
<!--   BLOCK BLASTER ‚Äì FINAL PROFESSIONAL PRELOADER    -->
<!-- ================================================== -->
<div id="blockBlasterLoader" style="
    position:fixed; top:0; left:0; width:100vw; height:100vh;
    background: linear-gradient(
        120deg,
        rgba(0,0,0,0.92) 0%,
        rgba(0,0,0,0.88) 50%,
        rgba(0,0,0,0.94) 100%
    );
    backdrop-filter: blur(2px);
    z-index:99999; display:flex; flex-direction:column;
    justify-content:center; align-items:center; overflow:hidden;
    font-family: 'Arial Black', Arial, sans-serif;
">

  <!-- Glowing block animation canvas -->
  <canvas id="loaderCanvas" width="420" height="420" style="
      border-radius:0;
      box-shadow:none;
      background: transparent;
      filter: drop-shadow(0 0 35px #60d4fa)
              drop-shadow(0 0 60px #a78bfa)
              drop-shadow(0 0 90px #f472b6);
  "></canvas>

  <!-- Neon Game Title -->
  <h1 style="
    color:#60d4fa; font-size:52px; margin:32px 0 10px; letter-spacing:10px;
    text-shadow:
      0 0 18px #60d4fa,
      0 0 35px #60d4fa,
      0 0 55px #a78bfa,
      0 0 85px #f472b6;
    animation: neonPulse 2.2s infinite alternate;
  ">
    BLOCK BLASTER
  </h1>

  <!-- Subtitle -->
  <p style="color:#a78bfa; font-size:20px; margin:0; opacity:0.9; letter-spacing:4px;">
    Addictive Block Action
  </p>

  <!-- Loading Text -->
  <div style="
      color:#d1d5db; margin-top:30px;
      font-size:16px; letter-spacing:2px;
      text-shadow:0 0 10px #60d4fa;
  ">
    Loading<span class="dots"></span>
  </div>
</div>

<!-- FULL MERGED CSS -->
<style>
/* Title neon pulse */
@keyframes neonPulse {
  0% {
    text-shadow:
      0 0 10px #60d4fa,
      0 0 20px #60d4fa,
      0 0 35px #a78bfa;
  }
  100% {
    text-shadow:
      0 0 20px #60d4fa,
      0 0 40px #a78bfa,
      0 0 70px #f472b6;
  }
}

/* Optional: extra glow pulse referenced in your message */
@keyframes glowPulse {
  from { text-shadow: 0 0 20px #00ff9d, 0 0 40px #00ff9d; }
  to   { text-shadow: 0 0 30px #00ff9d, 0 0 60px #00ff9d, 0 0 80px #00ff9d; }
}

/* FIXED animated dots */
.dots::after {
  content: '';
  animation: dots 1.4s infinite steps(1);
}

@keyframes dots {
  0%   { content: ''; }
  25%  { content: '.'; }
  50%  { content: '..'; }
  75%  { content: '...'; }
  100% { content: ''; }
}
	</style>

<script>
// Ultra-smooth falling + rotating neon blocks
const loader = document.getElementById('blockBlasterLoader');
const canvas = document.getElementById('loaderCanvas');
const ctx = canvas.getContext('2d');
let blocks = [];

class Block {
  constructor() {
    this.size = Math.random() * 25 + 18;
    this.x = Math.random() * canvas.width;
    this.y = -this.size;
    this.speed = Math.random() * 3.5 + 2.5;
    this.color = ['#ff0080','#00ff9d','#ffea00','#00d0ff','#ff2a6d'][Math.floor(Math.random()*5)];
    this.rotation = 0;
    this.rotSpeed = (Math.random() - 0.5) * 0.25;
  }
  update() {
    this.y += this.speed;
    this.rotation += this.rotSpeed;
    if (this.y > canvas.height + this.size) {
      this.y = -this.size;
      this.x = Math.random() * canvas.width;
    }
  }
  draw() {
    ctx.save();
    ctx.translate(this.x + this.size/2, this.y + this.size/2);
    ctx.rotate(this.rotation);
    ctx.fillStyle = this.color;
    ctx.shadowBlur = 20;
    ctx.shadowColor = this.color;
    ctx.fillRect(-this.size/2, -this.size/2, this.size, this.size);
    ctx.restore();
  }
}

// Create more blocks for richer effect
for(let i = 0; i < 22; i++) blocks.push(new Block());

function animate() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  blocks.forEach(b => { b.update(); b.draw(); });
  if (loader.offsetParent !== null) requestAnimationFrame(animate);
}
animate();

// Responsive canvas
function resizeCanvas() {
  const size = Math.min(380, window.innerWidth * 0.85);
  canvas.width = size;
  canvas.height = size;
}
resizeCanvas();
window.addEventListener('resize', resizeCanvas);

// === HIDE LOADER WHEN GAME IS READY ===
function hideBlockBlasterLoader() {
  loader.style.transition = 'opacity 0.8s ease-out';
  loader.style.opacity = '0';
  setTimeout(() => { loader.style.display = 'none'; }, 900);
}

// Never stuck longer than 4 seconds
setTimeout(hideBlockBlasterLoader, 95000);

// Call this from your script.js when everything is loaded
window.startBlockBlasterGame = hideBlockBlasterLoader;
		</script>


<!-- Game canvas -->
<canvas id="c"></canvas>

<!-- Gameplay HUD -->
<div class="hud">
	<div class="hud__score">
		<div class="score-lbl"></div>
		<div class="cube-count-lbl"></div>
	</div>
	<div class="pause-btn"><div></div></div>
	<div class="slowmo">
		<div class="slowmo__bar"></div>
	</div>
</div>

<!-- Menu System -->
<div class="menus">
	<div class="menu menu--main">
		<h1>Block Blaster</h1>
		<button type="button" class="play-normal-btn">PLAY GAME</button>
		<button type="button" class="play-casual-btn">CASUAL MODE</button>
		<div class="credits">3D game by <a href="https://lly-boob.github.io/Ultimate-pong/">LLydra Abong</a></div>
	</div>
	<div class="menu menu--pause">
		<h1>Paused</h1>
		<button type="button" class="resume-btn">RESUME GAME</button>
		<button type="button" class="menu-btn--pause">MAIN MENU</button>
	</div>
	<div class="menu menu--score">
		<h1>Game Over</h1>
		<h2>Your Score:</h2>
		<div class="final-score-lbl"></div>
		<div class="high-score-lbl"></div>
		<button type="button" class="play-again-btn">PLAY AGAIN</button>
		<button type="button" class="menu-btn--score">MAIN MENU</button>
	</div>
</div>

<!-- MUTE BUTTON -->
<div id="muteBtn" style="position:fixed;bottom:20px;right:20px;width:50px;height:50px;cursor:pointer;z-index:9999;">
  <svg viewBox="0 0 24 24" width="50" height="50" fill="#fff">
    <path d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z"/>
  </svg>
</div>



<!-- MUSIC + MUTE + SAFE PROP ADS INIT + SERVICE WORKER -->
<script>
  const music = document.getElementById('bgMusic');
  const muteBtn = document.getElementById('muteBtn');
  let muted = false;
  let started = false;
  let adLoaded = false;

  // PLAY MUSIC & LOAD PROP ADS ON FIRST TAP
  function startGame() {
    if (started) return;
    started = true;

    // Start music ‚Äî WITH ERROR LOGGING
    music.volume = 0.3;
    music.play()
      .then(() => {
        console.log('Music started');
      })
      .catch((err) => {
        console.warn('Music blocked until interaction:', err.message);
        // Optional: Show hint
        showUnmuteHint();
      });

    

    // Remove listeners
    document.removeEventListener('touchstart', startGame);
    document.removeEventListener('click', startGame);
  }

  // Add listeners
  document.addEventListener('touchstart', startGame, { once: true });
  document.addEventListener('click', startGame, { once: true });

  // MUTE BUTTON
  muteBtn.onclick = () => {
    muted = !muted;
    music.muted = muted;
    muteBtn.innerHTML = muted
      ? `<svg viewBox="0 0 24 24" width="50" height="50" fill="#aaa">
           <path d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02z"/>
         </svg>`
      : `<svg viewBox="0 0 24 24" width="50" height="50" fill="#fff">
           <path d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z"/>
         </svg>`;
  };
</script>

<!-- ===== Simple Fixed Share Button (Matches Mute Style) ===== -->
<style>
#shareBtn {
  position: fixed;
  bottom: 14px;       /* Same as your mute */
  left: 20px;         /* So it sits beside mute, you can adjust */
  width: 42px;
  height: 42px;
  cursor: pointer;
  z-index: 9999999;
  background: rgba(255,255,255,0.25);
  backdrop-filter: blur(6px);
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  border: 1px solid rgba(255,255,255,0.4);
}

#shareBtn svg {
  width: 55%;
  height: 55%;
  fill: #fff;
}
</style>

<div id="shareBtn">
  <!-- Universal Share Icon -->
  <svg viewBox="0 0 24 24">
    <path d="M18 16.08c-.76 0-1.44.3-1.96.77L8.91 12.7c.05-.23.09-.46.09-.7s-.04-.47-.09-.7l7.02-4.11A2.99 
    2.99 0 0018 7.91a3 3 0 10-3-3c0 .24.04.47.09.7L8.07 9.72A3.007 3.007 
    0 006 9a3 3 0 103 3c0-.24-.04-.47-.09-.7l7.12 4.17c.5-.44 
    1.15-.71 1.87-.71a3 3 0 100-6z"/>
  </svg>
</div>

<script>
(function(){
  const shareBtn = document.getElementById("shareBtn");
  const shareURL = window.location.href;

  shareBtn.addEventListener("click", async () => {

    // 1Ô∏è‚É£ If Web Share API works (mobile browser)
    if (navigator.share) {
      try {
        await navigator.share({
          title: "Play Block Blaster!",
          text: "Try this game! It's addictive üî•",
          url: shareURL
        });
        return;
      } catch (e) {
        console.log("Share cancelled.", e);
      }
    }

    // 2Ô∏è‚É£ Fallback for itch.io (copy link)
    try {
      await navigator.clipboard.writeText(shareURL);
      alert("Link copied! Share it with your friends üéÆ");
    } catch (e) {
      console.log("Clipboard blocked, using prompt.");

      // 3Ô∏è‚É£ FINAL fallback (always works)
      prompt("Copy this link:", shareURL);
    }

  });
})();
	</script>

<script>
// =========================
// Touch Input Booster (Safe)
// =========================

// This prevents the browser from interfering with your swipe
// but does NOT break scroll on other pages or other elements.
// Only the canvas is protected.

document.addEventListener("DOMContentLoaded", () => {
    const canvas = document.querySelector("canvas");
    if (!canvas) return;

    const opts = { passive: false };

    ["touchstart", "touchmove", "touchend"].forEach(ev => {
        canvas.addEventListener(ev, e => {
            // Only stop browser behavior IF the user touched the canvas
            e.preventDefault();
        }, opts);
    });

    canvas.style.touchAction = "none"; // ultra-safe, only affects canvas
});
	</script>

<style>

<script>
// =========================
// Touch Input Ultra Booster
// =========================

// Makes touchmove fire at maximum device speed
// without changing how your game handles swipes.
document.addEventListener("DOMContentLoaded", () => {
    const canvas = document.querySelector("canvas");
    if (!canvas) return;

    const opts = { passive: true }; 
    // passive:true means "do NOT block game logic"

    let lastX = 0;
    let lastY = 0;

    canvas.addEventListener("touchmove", e => {
        const t = e.touches[0];
        lastX = t.clientX;
        lastY = t.clientY;

        // You can read lastX / lastY anywhere,
        // the game will feel smoother because input refreshes faster.
    }, opts);

    // Make the browser render touch faster
    canvas.style.touchAction = "manipulation";
});
</script>

	
/* ===== Install Popup Animation ===== */
#autoInstallBox {
    opacity: 0;
    transform: translate(-50%, 20px);
    transition: all 0.6s ease;
}

#autoInstallBox.show {
    opacity: 1;
    transform: translate(-50%, 0);
    animation: bounceIn 0.6s ease-out;
}

@keyframes bounceIn {
    0% { transform: translate(-50%, 40px); }
    60% { transform: translate(-50%, -5px); }
    100% { transform: translate(-50%, 0); }
}
</style>

<!-- ===== AUTO INSTALL POPUP ===== -->
<div id="autoInstallBox" style="
    display:none;
    position: fixed;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    background: #111;
    color: #fff;
    padding: 15px 20px;
    border-radius: 12px;
    box-shadow: 0 4px 15px rgba(0,0,0,0.4);
    z-index: 999999;
    text-align: center;
    font-size: 16px;
">
    <div style="margin-bottom: 10px;">
        Install this game for faster play & offline access!
    </div>

    <button id="autoInstallBtn" style="
        background: #1e90ff;
        border: none;
        color: white;
        padding: 10px 18px;
        border-radius: 8px;
        font-size: 15px;
        cursor: pointer;
    ">
        Install Now
    </button>
</div>

<script>
/* ===== Install Prompt Logic ===== */
let deferredPrompt = null;
let popupShown = false;

window.addEventListener("beforeinstallprompt", (e) => {
    e.preventDefault();
    deferredPrompt = e;

    if (!popupShown) {
        setTimeout(showPopup, 2000); // show after 2 seconds
    }
});

function showPopup() {
    if (deferredPrompt) {
        const box = document.getElementById("autoInstallBox");
        box.style.display = "block";

        // Start animation
        setTimeout(() => {
            box.classList.add("show");
        }, 20);

        popupShown = true;

        // Re-show every 10 seconds until installed
        setTimeout(() => {
            if (deferredPrompt) showPopup();
        }, 10000);
    }
}

document.getElementById("autoInstallBtn").addEventListener("click", () => {
    if (!deferredPrompt) return;

    deferredPrompt.prompt();
    deferredPrompt = null;
    hidePopup();
});

// Hide forever once installed
window.addEventListener("appinstalled", () => {
    deferredPrompt = null;
    hidePopup();
});

function hidePopup() {
    const box = document.getElementById("autoInstallBox");
    box.classList.remove("show");

    setTimeout(() => {
        box.style.display = "none";
    }, 600);
}
</script>


<!-- ========================= -->
<!-- Open in Browser Prompt -->
<!-- ========================= -->
<div id="openBrowserBox">
  <button id="openBrowserBtn">üåê Open in Browser to install</button>
</div>

<style>
  #openBrowserBox {
    position: fixed;
    bottom: 20px;
    left: 20px;
    z-index: 9999;
    display: none;
    pointer-events: auto;
  }

  #openBrowserBtn {
    background: #ff9800;
    color: #fff;
    border: none;
    border-radius: 12px;
    padding: 10px 16px;
    font-size: 14px;
    cursor: pointer;
    box-shadow: 0 2px 6px rgba(0,0,0,0.25);
    transition: transform 0.2s ease, opacity 0.3s ease;
    opacity: 0;
  }

  #openBrowserBox.show #openBrowserBtn {
    opacity: 1;
    transform: scale(1.1);
    animation: bounce 1s infinite alternate;
  }

  @keyframes bounce {
    0% { transform: scale(1.1); }
    100% { transform: scale(1.2); }
  }
</style>

<script>
(function() {
  // Prevent showing multiple times per session
  if (sessionStorage.getItem("openBrowserClicked")) return;

  const ua = navigator.userAgent || navigator.vendor || window.opera;

  // Smart detection: common social media in-app browsers
  const socialAppPatterns = [
    /FBAN|FBAV/i,          // Facebook app
    /Instagram/i,           // Instagram
    /Twitter/i,             // Twitter
    /Snapchat/i,            // Snapchat
    /LinkedIn/i,            // LinkedIn
    /Reddit/i,              // Reddit
    /TikTok/i,              // TikTok
    /WhatsApp/i,            // WhatsApp
    /Messenger/i,           // Messenger
    /Pinterest/i            // Pinterest
  ];

  // Also detect known in-app browser patterns (iOS & Android)
  const inAppBrowserPatterns = [
    /CriOS/i,               // Chrome on iOS
    /FxiOS/i,               // Firefox on iOS
    /GSA/i                  // Google Search app
  ];

  // Check if user is in social media or in-app browser
  const isSocialApp = socialAppPatterns.some(rx => rx.test(ua));
  const isInAppBrowser = /FBAN|FBAV|Instagram|Twitter|Snapchat|LinkedIn|Reddit|TikTok|Messenger|WhatsApp|Pinterest/i.test(ua)
                        && !/Chrome|Safari|Firefox|Edge/i.test(ua);

  if (!isSocialApp && !isInAppBrowser) return; // Exit if not social media browser

  const box = document.getElementById("openBrowserBox");
  const btn = document.getElementById("openBrowserBtn");

  // Show button after a short delay
  setTimeout(() => {
    box.style.display = "block";
    requestAnimationFrame(() => box.classList.add("show"));
  }, 2000);

  // Open page in default browser
  btn.addEventListener("click", () => {
    window.open(window.location.href, "_blank");

    // Hide and mark as clicked
    box.classList.remove("show");
    setTimeout(() => box.style.display = "none", 300);
    sessionStorage.setItem("openBrowserClicked", "true");
  });
})();
	</script>


  <!-- All your existing HTML (canvas, hud, menus, mute button, etc.) stays 100% the same -->
  <canvas id="c"></canvas>
  <div class="hud">‚Ä¶</div>
  <div class="menus">‚Ä¶</div>
  <div id="muteBtn">‚Ä¶</div>
  <div id="shareBtn">‚Ä¶</div>
  <!-- etc. keep everything you already have -->



  <!-- ===================================================== -->
  <!--         MAGIC PERFORMANCE AUTO-ADAPTER ENGINE         -->
  <!-- ===================================================== -->
  <script src="https://unpkg.com/detect-gpu@5.0.38/dist/detect-gpu.min.js"></script>
  <script>
    // This whole block runs once at startup and decides the quality level
    (async () => {
      const gpu = new GpuJsDetector();
      const result = await gpu.getGPUTier({
        mobileBenchmarkPercentile: 50,   // realistic for phones
        desktopBenchmarkPercentile: 50
      });

      // tier goes from 0 (very weak) ‚Üí 3 (high-end)
      const tier = result.tier; // 0, 1, 2 or 3 (or "WEBGL_UNSUPPORTED")
      
      let scale = 1.0;
      let targetFps = 60;
      let lowQualityMode = false;

      if (tier <= 1) {               // very low-end phones (most Android < $200)
        scale = 0.65;
        targetFps = 30;
        lowQualityMode = true;
      } else if (tier === 2) {       // medium phones / old iPads
        scale = 0.85;
        targetFps = 45;
      } else if (tier >= 3) {        // good phones, all PCs
        scale = 1.0;
        targetFps = 60;
      }

      // Expose to your game code (script.js can read these if you ever want)
      window.PERF_TIER = tier;
      window.PERF_SCALE = scale;
      window.PERF_FPS = targetFps;
      window.LOW_QUALITY = lowQualityMode;

      // 1. Force lower resolution (the #1 fix for laggy WebGL on mobile)
      const canvas = document.getElementById('c');
      function resizeCanvas() {
        const dpr = window.devicePixelRatio || 1;
        const actualScale = lowQualityMode ? scale : Math.min(scale, 1);
        
        canvas.width  = canvas.clientWidth  * dpr * actualScale;
        canvas.height = canvas.clientHeight * dpr * actualScale;

        // CSS size stays full screen (sharp on high-dpi, pixelated but fast on low)
        canvas.style.width  = '100%';
        canvas.style.height = '100%';
      }

      resizeCanvas();
      window.addEventListener('resize', resizeCanvas);

      // 2. Cap FPS on low-end devices (prevents burning CPU/GPU)
      let lastFrameTime = 0;
      const originalRaf = window.requestAnimationFrame;
      window.requestAnimationFrame = function(callback) {
        return originalRaf(function(time) {
          if (!lastFrameTime) lastFrameTime = time;
          const delta = time - lastFrameTime;
          const interval = 1000 / targetFps;
          
          if (delta > interval) {
            lastFrameTime = time - (delta % interval);
            callback(time);
          } else {
            originalRaf(arguments.callee);
          }
        });
      };

      // 3. Remove 300 ms tap delay + make touch super responsive
      canvas.style.touchAction = 'none';
      ['touchstart','touchmove','touchend','touchcancel'].forEach(ev => {
        canvas.addEventListener(ev, e => e.preventDefault(), { passive: false });
      });

      // 4. Optional: force lower precision in shaders on trash GPUs
      // (many raw WebGL games use highp everywhere ‚Üí death on Mali/Adreno 5xx)
      if (lowQualityMode) {
        const originalGetContext = HTMLCanvasElement.prototype.getContext;
        HTMLCanvasElement.prototype.getContext = function(type, attributes) {
          if (type.includes('webgl')) {
            attributes = attributes || {};
            attributes.precisionHint = 'low'; // custom flag we add
          }
          return originalGetContext.call(this, type, attributes);
        };
      }

      console.log(`Block Blaster ‚Üí Device tier \( {tier} ‚Üí Scale: \){scale.toFixed(2)}, FPS cap: ${targetFps}`);
    })();
	</script>
	
	<script>
// ===================== Performance Helper for Swipe Match-3 =====================

// FPS monitor (optional, helps see if game drops frames)
(function() {
    let last = performance.now();
    let frames = 0;
    function fpsMonitor() {
        const now = performance.now();
        frames++;
        if (now - last >= 1000) {
            console.log("FPS:", frames);
            frames = 0;
            last = now;
        }
        requestAnimationFrame(fpsMonitor);
    }
    fpsMonitor();
})();

// Hardware acceleration helper for tiles
function accelerateTiles(tileSelector) {
    const tiles = document.querySelectorAll(tileSelector);
    tiles.forEach(tile => {
        tile.style.transform = "translate3d(0,0,0)";
        tile.style.willChange = "transform";
    });
}

// Smooth animation wrapper using requestAnimationFrame
function animateTile(tile, targetX, targetY, duration = 300, callback) {
    const startX = tile.offsetLeft;
    const startY = tile.offsetTop;
    const deltaX = targetX - startX;
    const deltaY = targetY - startY;
    const startTime = performance.now();

    function step(now) {
        const elapsed = now - startTime;
        const progress = Math.min(elapsed / duration, 1);
        tile.style.transform = `translate3d(${deltaX*progress}px, ${deltaY*progress}px, 0)`;
        if (progress < 1) {
            requestAnimationFrame(step);
        } else {
            if (callback) callback();
        }
    }
    requestAnimationFrame(step);
}

// Throttle expensive game updates (e.g., combo checks)
function throttle(fn, limit = 50) {
    let lastCall = 0;
    return function(...args) {
        const now = performance.now();
        if (now - lastCall >= limit) {
            lastCall = now;
            fn.apply(this, args);
        }
    }
}

// ===================== Usage Examples =====================

// 1. Accelerate all tiles
accelerateTiles(".tile"); // replace ".tile" with your tile class

// 2. Animate a tile smoothly
// animateTile(document.querySelector(".tile"), 200, 300, 300);

// 3. Throttle heavy functions
// const checkCombosThrottled = throttle(checkCombos, 50);
	</script>

	<!-- ====================================================== -->
<!-- PERFORMANCE BOOST ENGINE v3 ‚Äî ADAPTIVE SUPER BOOSTER    -->
<!-- Ultra-safe sandbox: no overrides, opt-in adaptions only -->
<!-- Paste BEFORE your game script                          -->
<!-- ====================================================== -->
<script>
(function () {
  // single, immutable global handle for optional diagnostics (safe & minimal)
  if (window.__PerfBoostV3) return; // prevent double-load
  const __PerfBoostV3 = (() => {

    /* ===========================
       Internal state (private)
       =========================== */
    const state = {
      tier: "unknown",
      fps: 60,
      lowDevice: false,
      frameTimes: [],
      lastNow: performance.now(),
      mem: { usedMB: null, totalMB: null },
      thermalThrottled: false,
      lastThermalCheck: 0,
      emergencyMode: false
    };

    /* ===========================
       Utilities (no globals touched)
       =========================== */
    function safeLog(...args) {
      // reduce noise; use console.debug to keep logs hidden by default
      if (window.location.search.indexOf("perfboost_debug") !== -1) {
        console.debug("[PerfBoostV3]", ...args);
      }
    }

    function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }

    /* ===========================
       Passive FPS & Memory Monitor
       - does NOT replace requestAnimationFrame
       - purely observational
       =========================== */
    function monitorLoop() {
      try {
        requestAnimationFrame((now) => {
          const delta = now - state.lastNow || 16.67;
          state.lastNow = now;
          const fps = 1000 / delta;
          state.frameTimes.push(fps);
          if (state.frameTimes.length > 30) state.frameTimes.shift();
          const avg = state.frameTimes.reduce((a,b)=>a+b,0) / state.frameTimes.length || fps;
          state.fps = Math.round(avg);
          // mark low device if sustained low fps
          if (avg < 40) state.lowDevice = true;
          else if (avg > 48) state.lowDevice = false;

          // optional memory read (non-fatal if unavailable)
          if (performance && performance.memory) {
            const mem = performance.memory;
            // usedJSHeapSize / (1024*1024) gives MB
            state.mem.usedMB = Math.round(mem.usedJSHeapSize / 1048576);
            state.mem.totalMB = Math.round(mem.jsHeapSizeLimit / 1048576);
            // if used exceeds 85% -> emergency
            if (state.mem.usedMB && state.mem.totalMB &&
                state.mem.usedMB / state.mem.totalMB > 0.85) {
              state.emergencyMode = true;
            } else {
              state.emergencyMode = false;
            }
          }

          // lightweight thermal-like heuristic (doesn't require special APIs)
          // check every 3s
          const nowTs = Date.now();
          if (nowTs - state.lastThermalCheck > 3000) {
            state.lastThermalCheck = nowTs;
            // crude: if recent fps dropped drastically -> possible throttling
            const recent = state.frameTimes.slice(-5);
            if (recent.length >= 3) {
              const minRecent = Math.min(...recent);
              if (minRecent < Math.max(20, state.fps * 0.5)) {
                state.thermalThrottled = true;
              } else {
                state.thermalThrottled = false;
              }
            }
          }
        });
      } catch (e) {
        // never throw
      } finally {
        // continue monitoring
        setTimeout(monitorLoop, 1); // minimal delay; purely observational
      }
    }

    /* ===========================
       Adaptive helpers (safe, non-invasive)
       - These functions DO NOT override your game loop.
       - They only *offer* guidance or opt-in effects.
       =========================== */

    // 1) Recommended frame-skip decision ‚Äî game can call this each frame.
    //    returns {skipRender: boolean, skipPhysics: boolean}
    function getFrameAllowance() {
      const fps = state.fps || 60;
      // skip more often when fps low or emergency
      const emergency = state.emergencyMode || state.thermalThrottled;
      // compute probability of skipping render this frame (0..1)
      let skipProb = 0;
      if (fps >= 50 && !emergency) skipProb = 0;
      else if (fps >= 40) skipProb = 0.1;
      else if (fps >= 30) skipProb = 0.25;
      else skipProb = 0.5 + (emergency ? 0.25 : 0);

      // deterministic-ish skip using time seed to avoid heavy logic
      const t = Math.floor(performance.now() / 16); // frame-ish tick
      const seed = (t * 9301 + 49297) % 233280;
      const rand = (seed % 1000) / 1000;
      const skipRender = rand < skipProb;
      const skipPhysics = emergency && (rand < (skipProb * 0.6));

      return { skipRender, skipPhysics, fps: state.fps, emergency };
    }

    // 2) Adaptive scale suggestion ‚Äî safe: does NOT change canvas content,
    //    only suggests a CSS scale factor. Game may read and apply if it wants.
    //    If a canvas has opt-in attribute data-perfboost-scale="auto" we will
    //    apply a non-destructive CSS scale to *that* canvas (no size attr changes).
    function computeScaleSuggestion() {
      // target base resolution ~ device pixel ratio
      const dpr = window.devicePixelRatio || 1;
      let base = 1;
      if (state.lowDevice || state.fps < 40) base = 0.75;
      if (state.emergencyMode || state.fps < 30) base = 0.5;
      return clamp(base, 0.5, 1) / dpr;
    }

    // 3) Auto-attach safe CSS scaling to canvas only if canvas opted in
    function attachCanvasScalingIfOptIn() {
      try {
        // find canvases with data-perfboost-scale="auto"
        const canvases = Array.from(document.querySelectorAll('canvas[data-perfboost-scale="auto"]'));
        if (!canvases.length) return;
        const scale = computeScaleSuggestion();
        canvases.forEach(c => {
          // apply CSS transform only (non-destructive)
          c.style.willChange = "transform";
          c.style.transformOrigin = "0 0";
          // preserve integer pixel sizes visually by using transform scale
          c.style.transform = `scale(${scale})`;
          // optionally reduce CSS layout jitter by setting image-rendering
          c.style.imageRendering = "pixelated";
          // expose applied scale as attribute for game to read
          c.setAttribute("data-perfboost-applied-scale", String(scale));
        });
      } catch (e) {
        // fail silently
      }
    }

    /* ===========================
       Emergency memory/free-up strategy (non-invasive)
       - Removes nodes that are clearly marked by developer
       - Does not touch other DOM
       =========================== */
    function emergencyCleanupSweep() {
      try {
        // only run if emergencyMode true
        if (!state.emergencyMode) return;
        // developers can mark expendable nodes: class .perfboost-disposable
        const nodes = document.querySelectorAll(".perfboost-disposable");
        nodes.forEach(n => {
          try { n.remove(); } catch (e) {}
        });
        safeLog("Emergency cleanup sweep executed, removed:", nodes.length);
      } catch (e) {}
    }

    /* ===========================
       Passive UI: small invisible overlay for status (Shadow DOM)
       - Only present if developer explicitly sets data-perfboost-ui="visible"
       - This ensures ZERO visual interference by default.
       =========================== */
    function maybeCreateStatusOverlay() {
      try {
        const visible = document.querySelector('[data-perfboost-ui="visible"]');
        if (!visible) return;
        // create a tiny non-interactive overlay in shadow root
        const host = document.createElement("div");
        host.style.position = "fixed";
        host.style.right = "6px";
        host.style.bottom = "6px";
        host.style.zIndex = "2147483646"; // very top but non-interactive
        host.style.pointerEvents = "none";
        const shadow = host.attachShadow({mode: "closed"});
        const rootDiv = document.createElement("div");
        rootDiv.style.fontSize = "11px";
        rootDiv.style.padding = "6px 8px";
        rootDiv.style.borderRadius = "6px";
        rootDiv.style.background = "rgba(0,0,0,0.35)";
        rootDiv.style.color = "white";
        rootDiv.style.backdropFilter = "blur(2px)";
        rootDiv.style.pointerEvents = "none";
        rootDiv.textContent = `PerfBoost v3 ‚Äî fps: ${state.fps}`;
        shadow.appendChild(rootDiv);
        document.documentElement.appendChild(host);

        // update loop
        setInterval(() => {
          try {
            rootDiv.textContent = `PerfBoost v3 ‚Äî fps: ${state.fps} tier:${state.tier}${state.emergencyMode ? " ‚ö†" : ""}`;
          } catch (e) {}
        }, 600);
      } catch (e) {}
    }

    /* ===========================
       Non-invasive event broadcast API
       - Game can listen: window.addEventListener('perfboost:update', e=>{})
       - This emits regular read-only snapshots but DOES NOT allow mutation.
       =========================== */
    function broadcastState() {
      try {
        const snapshot = {
          fps: state.fps,
          tier: state.tier,
          lowDevice: state.lowDevice,
          mem: state.mem,
          emergencyMode: state.emergencyMode,
          thermalThrottled: state.thermalThrottled,
          timestamp: Date.now()
        };
        const evt = new CustomEvent('perfboost:update', { detail: snapshot });
        // dispatch non-cancelable to avoid interference
        window.dispatchEvent(evt);
      } catch (e) {}
    }

    /* ===========================
       Init: detect device tier + start loops
       =========================== */
    function detectTier() {
      const cores = navigator.hardwareConcurrency || 2;
      const mem = navigator.deviceMemory || 2;
      const smallScreen = (window.screen.width || 0) < 540 || (window.screen.height || 0) < 540;
      if (cores <= 4 || mem <= 2 || smallScreen) {
        state.tier = "low";
        state.lowDevice = true;
      } else if (cores <= 6) {
        state.tier = "mid";
      } else state.tier = "high";
    }

    // periodic tasks
    function periodicTasks() {
      try {
        attachCanvasScalingIfOptIn();   // safe CSS scaling for opt-in canvases
        emergencyCleanupSweep();        // remove .perfboost-disposable nodes if emergency
        broadcastState();               // emit snapshot
      } catch (e) {}
      setTimeout(periodicTasks, 1000); // run every 1s
    }

    // public read-only API (frozen)
    const publicAPI = Object.freeze({
      // read-only snapshot retrieval
      getInfo: () => ({
        fps: state.fps,
        tier: state.tier,
        lowDevice: state.lowDevice,
        mem: Object.assign({}, state.mem),
        emergencyMode: state.emergencyMode,
        thermalThrottled: state.thermalThrottled
      }),
      // recommended frame allowance helper ‚Äî safe for game loops to call every frame
      getFrameAllowance,
      // compute scale suggestion (game may use or ignore)
      computeScaleSuggestion,
      // developer can trigger a manual light cleanup (only removes .perfboost-disposable)
      manualCleanup: () => { emergencyCleanupSweep(); },
      // version
      version: "3.0.0"
    });

    /* ===========================
       Start everything (non-invasive)
       =========================== */
    function start() {
      detectTier();
      monitorLoop();     // passive FPS/memory monitor
      periodicTasks();   // periodic gentle tasks
      maybeCreateStatusOverlay(); // only if developer opted in
      safeLog("PerfBoostV3 started", publicAPI.getInfo());
    }

    // auto-start after DOMInteractive so it doesn't fight initial parsing
    if (document.readyState === "complete" || document.readyState === "interactive") {
      setTimeout(start, 300);
    } else {
      document.addEventListener("DOMContentLoaded", () => setTimeout(start, 300), { once: true });
    }

    // return public API for diagnostics ‚Äî attach minimal immutable handle
    return publicAPI;
  })();

  // attach a minimal, read-only handle for optional use by the developer
  try {
    Object.defineProperty(window, '__PerfBoostV3', {
      value: __PerfBoostV3,
      writable: false,
      configurable: false,
      enumerable: false
    });
  } catch (e) {
    // if defineProperty fails, silently ignore (still safe)
    window.__PerfBoostV3 = __PerfBoostV3;
  }

})();
</script>
<!-- ====================================================== -->
<!--            PERFORMANCE BOOST ENGINE v3 END            -->
<!-- ====================================================== -->

        
	


<!-- =============================================================== -->
<!-- ULTRA SAFE AD + FLICKER ABSORBER ENGINE v5 (Safe ‚Ä¢ Device-Aware) -->
<!-- - Shadow DOM + Triple Buffering                                -->
<!-- - Device checks: FPS, memory, battery (if available)           -->
<!-- - Opt-in, non-invasive (use data-ultraad-disable="true" to skip)-->
<!-- - Minimal immutable handle: window.__UltraAdV5 (read-only)     -->
<!-- =============================================================== -->
<div id="ultra-ad-root" aria-hidden="true" style="width:320px;height:50px;margin:auto;text-align:center; visibility:hidden;"></div>

<script>
(function () {
  if (window.__UltraAdV5Loaded) return;
  window.__UltraAdV5Loaded = true;

  // CONFIG (safe conservative defaults)
  const CONFIG = Object.freeze({
    AD_URL: "https://example.com/your-ad.html", // ‚Üê replace with your ad URL
    WIDTH: 320,
    HEIGHT: 50,
    LOAD_DELAY_MS: 900,        // wait after window.load for stability
    FPS_MIN_SAFE: 35,          // only show ad if avg fps >= this
    MEM_USAGE_MAX_RATIO: 0.80, // only show ad if JS heap < 80% of limit (if available)
    BATTERY_MIN_RATIO: 0.20,   // avoid showing when battery is below this (if detected)
    MAX_LOAD_RETRIES: 2        // number of times to attempt stabilize/load
  });

  // Private state
  const state = {
    running: true,
    adShown: false,
    retries: 0,
    fpsSamples: [],
    lastNow: performance.now(),
    avgFps: 60,
    mem: { usedMB: null, totalMB: null },
    batteryLevel: null,
    batteryCharging: null,
    reasonSkip: null
  };

  // Utilities
  function safeLog(...args) {
    if (location.search.indexOf("ultraad_debug") !== -1) console.debug("[UltraAdV5]", ...args);
  }

  function clamp(v,a,b){return Math.max(a,Math.min(b,v));}

  // Passive FPS monitor (observational only)
  function fpsProbe() {
    try {
      requestAnimationFrame((now) => {
        const dt = Math.max(1, now - state.lastNow);
        state.lastNow = now;
        const fps = 1000 / dt;
        state.fpsSamples.push(fps);
        if (state.fpsSamples.length > 40) state.fpsSamples.shift();
        const avg = state.fpsSamples.reduce((a,b)=>a+b,0) / state.fpsSamples.length;
        state.avgFps = Math.round(avg);
      });
    } catch (e) {}
    // schedule lightweight next probe (non-blocking)
    setTimeout(fpsProbe, 1);
  }

  // Memory probe (if available)
  function memProbe() {
    try {
      if (performance && performance.memory) {
        const mem = performance.memory;
        state.mem.usedMB = Math.round(mem.usedJSHeapSize / 1048576);
        state.mem.totalMB = Math.round(mem.jsHeapSizeLimit / 1048576);
      } else {
        state.mem.usedMB = null;
        state.mem.totalMB = null;
      }
    } catch (e) { state.mem.usedMB = null; state.mem.totalMB = null; }
    setTimeout(memProbe, 2500);
  }

  // Battery probe (best-effort, non-blocking)
  function batteryProbe() {
    try {
      if (navigator.getBattery) {
        navigator.getBattery().then(batt => {
          state.batteryLevel = batt.level; // 0..1
          state.batteryCharging = batt.charging;
          // update on change
          batt.addEventListener('levelchange', ()=> state.batteryLevel = batt.level);
          batt.addEventListener('chargingchange', ()=> state.batteryCharging = batt.charging);
        }).catch(()=>{/*ignore*/});
      }
    } catch (e) {}
  }

  // Decide whether it is safe to show ad
  function isSafeToShow() {
    // opt-out via attribute
    const root = document.getElementById("ultra-ad-root");
    if (!root || root.getAttribute("data-ultraad-disable") === "true") {
      state.reasonSkip = "disabled-via-attribute";
      return false;
    }

    // fps check
    if (state.avgFps && state.avgFps < CONFIG.FPS_MIN_SAFE) {
      state.reasonSkip = "low-fps";
      return false;
    }

    // memory check (if available)
    if (state.mem.totalMB && state.mem.usedMB) {
      if (state.mem.usedMB / state.mem.totalMB > CONFIG.MEM_USAGE_MAX_RATIO) {
        state.reasonSkip = "high-memory";
        return false;
      }
    }

    // battery check (if available)
    if (state.batteryLevel != null && state.batteryLevel < CONFIG.BATTERY_MIN_RATIO && state.batteryCharging === false) {
      // low battery and not charging -> skip ads
      state.reasonSkip = "low-battery";
      return false;
    }

    // otherwise ok
    state.reasonSkip = null;
    return true;
  }

  // Event broadcaster (non-intrusive)
  function emitStatus() {
    try {
      const snap = {
        adShown: state.adShown,
        avgFps: state.avgFps,
        mem: Object.assign({}, state.mem),
        batteryLevel: state.batteryLevel,
        batteryCharging: state.batteryCharging,
        reasonSkip: state.reasonSkip,
        timestamp: Date.now()
      };
      window.dispatchEvent(new CustomEvent('ultraadv5:status', { detail: snap }));
    } catch (e) {}
  }

  // Triple-buffer stabilizer + shadow DOM encapsulation
  function createBuffers(rootEl) {
    // Use shadow root to avoid CSS collisions
    const host = document.createElement('div');
    host.setAttribute('aria-hidden','true');
    const shadow = host.attachShadow({ mode: 'closed' });

    // styles (scoped)
    const style = document.createElement('style');
    style.textContent = `
      :host{display:block;width:${CONFIG.WIDTH}px;height:${CONFIG.HEIGHT}px}
      .ghost{opacity:0; transform:translateZ(0); will-change:opacity,transform}
      .final{opacity:0; transition:opacity .22s ease-out}
      iframe{width:${CONFIG.WIDTH}px;height:${CONFIG.HEIGHT}px;border:0;display:block}
    `;
    shadow.appendChild(style);

    // Offscreen buffer (hidden in light DOM)
    const offscreen = document.createElement('div');
    offscreen.style.display = 'none';

    // Ghost layer (compositor layer)
    const ghost = document.createElement('div');
    ghost.className = 'ghost';
    ghost.style.pointerEvents = 'none';

    // Final layer (will fade-in)
    const final = document.createElement('div');
    final.className = 'final';
    final.style.pointerEvents = 'none';

    shadow.appendChild(offscreen);
    shadow.appendChild(ghost);
    shadow.appendChild(final);

    rootEl.appendChild(host);

    return { offscreen, ghost, final, host, shadow };
  }

  // Create iframe with strict sandboxing by default
  function makeAdIframe() {
    const iframe = document.createElement('iframe');
    iframe.src = CONFIG.AD_URL;
    iframe.width = String(CONFIG.WIDTH);
    iframe.height = String(CONFIG.HEIGHT);
    iframe.loading = "lazy";
    // Conservative sandbox - adjust if your ad needs more permissions
    iframe.setAttribute('sandbox', 'allow-scripts allow-same-origin'); 
    iframe.style.display = 'block';
    iframe.addEventListener('error', ()=> safeLog('iframe load error'));
    return iframe;
  }

  // Stabilize & reveal ad (triple-buffer dance)
  function stabilizeAndReveal(buffers, iframe) {
    try {
      // place iframe in offscreen first
      buffers.offscreen.appendChild(iframe);

      // Wait a bit for the iframe to load content frames (non-blocking)
      // Use conservative two requestAnimationFrame steps to let compositor settle
      requestAnimationFrame(() => {
        requestAnimationFrame(() => {
          // move to ghost (GPU composited) layer
          buffers.ghost.appendChild(iframe);

          // let compositor settle across two frames
          requestAnimationFrame(() => {
            requestAnimationFrame(() => {
              // final move and fade-in
              buffers.final.appendChild(iframe);
              buffers.final.style.opacity = '1';
              // make host visible
              const rootEl = document.getElementById("ultra-ad-root");
              if (rootEl) rootEl.style.visibility = "visible";
              state.adShown = true;
              safeLog("UltraAdV5: ad displayed");
              emitStatus();
            });
          });

        });
      });

    } catch (e) {
      safeLog("UltraAdV5: stabilize error", e);
    }
  }

  // Core load flow (conservative retry)
  function tryLoadAd(buffers) {
    if (!isSafeToShow()) {
      emitStatus();
      return;
    }
    if (state.retries > CONFIG.MAX_LOAD_RETRIES) {
      state.reasonSkip = "max-retries";
      emitStatus();
      return;
    }
    state.retries++;

    const iframe = makeAdIframe();
    // Wait for iframe to report load OR timeout (whichever first)
    const loadTimeout = setTimeout(() => {
      safeLog("UltraAdV5: iframe load timeout");
      // Still attempt stabilization (some browsers render even without 'load' firing)
      stabilizeAndReveal(buffers, iframe);
    }, 3000);

    iframe.addEventListener('load', () => {
      clearTimeout(loadTimeout);
      stabilizeAndReveal(buffers, iframe);
    });

    // If iframe errors early, abort and emit
    iframe.addEventListener('error', () => {
      clearTimeout(loadTimeout);
      safeLog("UltraAdV5: iframe error during load");
      emitStatus();
    });
  }

  // Bootstrap sequence: wait for page + delay, then run safe checks, then attempt to load
  function bootstrap() {
    try {
      const root = document.getElementById("ultra-ad-root");
      if (!root) return;
      // quick guard: root can opt-out with data-ultraad-disable="true"
      if (root.getAttribute("data-ultraad-disable") === "true") {
        state.reasonSkip = "disabled-via-attribute";
        emitStatus();
        return;
      }

      // create buffers inside shadow to avoid CSS collisions
      const buffers = createBuffers(root);

      // run initial safety evaluation; start probes
      fpsProbe();
      memProbe();
      batteryProbe();

      // after window load + stable delay -> decide and try loading
      function onReadyToAttempt() {
        if (!isSafeToShow()) {
          // schedule a gentle re-check later (ad will only show if conditions improve)
          state.reasonSkip = state.reasonSkip || "initial-safety-fail";
          emitStatus();
          setTimeout(() => {
            if (!state.adShown) tryLoadAd(buffers);
          }, 2500);
          return;
        }
        tryLoadAd(buffers);
      }

      if (document.readyState === "complete") {
        setTimeout(onReadyToAttempt, CONFIG.LOAD_DELAY_MS);
      } else {
        window.addEventListener('load', () => setTimeout(onReadyToAttempt, CONFIG.LOAD_DELAY_MS), { once: true });
      }

    } catch (e) { safeLog("UltraAdV5 bootstrap error", e); }
  }

  // Expose a tiny, read-only API for diagnostics and opt-in actions
  const publicAPI = Object.freeze({
    getInfo: () => ({
      adShown: state.adShown,
      avgFps: state.avgFps,
      mem: Object.assign({}, state.mem),
      batteryLevel: state.batteryLevel,
      batteryCharging: state.batteryCharging,
      reasonSkip: state.reasonSkip,
      retries: state.retries
    }),
    // devs can ask the engine to attempt a re-evaluation & load (safe)
    attemptReload: () => {
      try {
        const root = document.getElementById("ultra-ad-root");
        if (!root) return;
        // only allow manual reload if ad not shown
        if (state.adShown) return;
        // dispatch an event for logs
        window.dispatchEvent(new CustomEvent('ultraadv5:manual-reload'));
        // small delay for safety
        setTimeout(bootstrap, 300);
      } catch (e) {}
    },
    version: "5.0.0"
  });

  // Attach immutable handle (non-writable, non-configurable)
  try {
    Object.defineProperty(window, '__UltraAdV5', {
      value: publicAPI,
      writable: false,
      configurable: false,
      enumerable: false
    });
  } catch (e) {
    window.__UltraAdV5 = publicAPI;
  }

  // start
  bootstrap();

  // periodic emitter for external observers (optional)
  setInterval(emitStatus, 1500);

})();
</script>
<!-- =============================================================== -->
<!-- ULTRA SAFE AD + FLICKER ABSORBER ENGINE v5 END                    -->
<!-- =============================================================== -->            
	
            


	<!-- GAME SCRIPT -->
<script type="module" src="./script.js"></script>

<script src="./menja/dist/ads.js"></script>  <!
	
</body>
</html>
